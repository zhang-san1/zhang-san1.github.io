import{_ as e,W as a,X as i,Y as r}from"./framework-6447176f.js";const l="/assets/6e5f0672293baa4523d38f2b1f65af6-dd8db8fd.png",o="/assets/78c228fdfb1aaa5f01e9161e8d2462a-45c5cd11.png",s="/assets/dbd3e66cbca10d32ba0039a61f22f4a-e8f21d6b.png",n={},d=r('<h1 id="drools概述" tabindex="-1"><a class="header-anchor" href="#drools概述" aria-hidden="true">#</a> Drools概述</h1><h2 id="什么是规则引擎" tabindex="-1"><a class="header-anchor" href="#什么是规则引擎" aria-hidden="true">#</a> 什么是规则引擎？</h2><p>规则引擎是伴随着IT系统发展、业务复杂度提升而发展起来的，将业务决策功能从代码实现中剥离的引擎系统。规则引擎用自身可识别的语言来描述和编写业务规则，它接收输入参数(数据)，通过预编译或预加载的规则推导出结果，供调用方使用或直接触发外部系统接口，以对输入事件做出反馈(动作),如图所示:</p><p><img src="'+l+'" alt="image-20230309170412197"></p><p>规则引擎把业务规则的编写和修改工作从业务系统的开发人员身上转移到具体系统运营的业务人员身上，因而避免了从业务到代码再到业务的长链路知识传递过程，降低了出错率。规则引擎还减少了因为业务变更而重新发布系统的次数，增加了系统的健壮性，提升了研发效率，缩短了从想法到实现的周期，从而提高了效益。</p><h2 id="drools是什么" tabindex="-1"><a class="header-anchor" href="#drools是什么" aria-hidden="true">#</a> Drools是什么</h2><p>Drools是业务规则管理系统(BRMS)的一种实现方式。它提供了核心业务规则引擎(BRE)、基于Web的规则编写和管理的控制台(Drools Workbench)。它能运行基于DMN(决策模型和表示法)定义的决策模型，还能用来导入和运行遵从PMML(预言模型标记语言)的机器学习预测模型。</p><p>Drools是用Java实现的规则引擎。</p><p>Drools社区的顶级项目有以下几个</p><ul><li>Drools Workbench: 规则编写和管理的Web管控台</li><li>Drools Expert: 核心业务规则引擎</li><li>Drools Fusion: 复杂事件处理</li><li>jBPM: 流程引擎、规则流引擎</li><li>OptaPlanner: 约束求解器，轻量级规划调度引擎</li></ul><h2 id="drools的组件" tabindex="-1"><a class="header-anchor" href="#drools的组件" aria-hidden="true">#</a> Drools的组件</h2><p>Drools包含以下几个组件</p><ul><li>Business Central: 业务中心，是规则编写和管理的Web控制台</li><li>KIE Serve: 规则执行的服务器，可以部署在任何Web服务器上</li><li>Asset Repository: 一个Git库，用来保存编写好的规则和相关文件</li><li>Artfact Repository: 一个制品库，用来保存编译打包好的制品，如kjar文件等 这几个组件之间的关系如图所示： <img src="'+o+`" alt="image-20230309170412197"> 通常，用户会登录到Business Central 中编写规则，将规则保存到Assert Repository 中，再将规则编译、构建、发布成kjar文件保存到Artfact Repository 中，最后通过Business Central创建KIE Server，将规则对应的kjar文件部署到KIE Server中运行，以供外部系统调用。</li></ul><h2 id="drools的使用方式" tabindex="-1"><a class="header-anchor" href="#drools的使用方式" aria-hidden="true">#</a> Drools的使用方式</h2><ul><li>嵌入式: 将规则文件嵌入程序内部，应用程序通过引入Drools运行时的依赖库来驱动规则引擎。</li><li>远程调用模式: 将规则独立于应用程序之外，以Drools的规则服务器(KIE Server)方式运行并接收外部请求。</li><li>云提供模式: 将规则服务器以容器的方式运行在容器平台上，规则的编写、修改、维护都在云平台上操作。（Docker）</li></ul><h2 id="drools的核心概念" tabindex="-1"><a class="header-anchor" href="#drools的核心概念" aria-hidden="true">#</a> Drools的核心概念</h2><h3 id="规则语言" tabindex="-1"><a class="header-anchor" href="#规则语言" aria-hidden="true">#</a> 规则语言</h3><p>Drools是以声明式的方式编写规则的，目前支持两种语言：java和MVEL。drools定义的规则文件保存在以DRL(Drools Rule Language)为扩展名的文件中。 一个规则文件通常由以下几部分组成：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>package 规则所属的包

rule 规则的名称

when 
  规则触发的条件 也称规则的左手边(Left Hand Side, LHS)

then
  触发后规则要做的动作，也称规则的右手边(Right Hand Side,RHS)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>package 对规则的存放位置进行了定义，如同java里的package rule、when、then、end 是规则语言保留的关键字 规则的名称用来标识被定义的规则，同一个包下的规则名必须唯一 when定义了规则的触发条件 then定义了规则触发后要做的动作 一个规则只能存放在一个规则文件中，不能跨多个规则文件存放，而一个规则文件可以存放多个规则</p><h3 id="事实对象" tabindex="-1"><a class="header-anchor" href="#事实对象" aria-hidden="true">#</a> 事实对象</h3><p>事实对象(fact)是Drools用来评估条件和执行结果的模型对象，也称事实数据</p><ul><li>事实对象可以理解为java的POJO类</li><li>事实对象可以有自己的函数，提供给规则引擎在&quot;那么&quot;的部分调用</li><li>事实对象可以从数据库中加载</li><li>事实对象不需要继承任何类或实现某些接口 Drools要求事实对象必须遵从java Bean的规范</li><li>Stated fact(陈述事实对象):规则调用者提供给规则的事实对象 -Inferred fact（推断事实对象）:规则引擎根据调用者提供的陈述事实通过计算推导出的事实对象，推断事实可能会随着时间的变化而变化。</li></ul><h3 id="决策引擎" tabindex="-1"><a class="header-anchor" href="#决策引擎" aria-hidden="true">#</a> 决策引擎</h3><p>决策引擎(Decision Engine)是Drools的核心，也可以称作Drools的大脑，如图所示决策引擎从生产内存(Production Memory)中加载定义的规则，再从工作内存(Working Memory)中读取事实对象，然后根据规则条件，用Phreak算法进行模式匹配(Pattern Matching)，也就是执行规则定义中的&quot;如果&quot;部分，如果匹配成功就把相应的动作(规则定义中的&quot;那么&quot;)部分放到议程(Agenda)队列中。</p><p><img src="`+s+'" alt="image-20230309170412197"></p><ul><li>议程是规则引擎的触发事件队列，所有已经匹配的规则都会在议程中排队，等待规则引擎逐个执行。</li><li>生产内存是保存编译后的Drools规则的位置</li><li>工作内存是事实对象(数据)存放的位置，外部提供给规则引擎的陈述事实和规则引擎产生或修改后的推断事实都保存在工作内存中。</li></ul><h3 id="社区版drools与企业级的decision-manager" tabindex="-1"><a class="header-anchor" href="#社区版drools与企业级的decision-manager" aria-hidden="true">#</a> 社区版Drools与企业级的Decision Manager</h3><p>两者都是开源的，只是侧重点不同</p><ul><li>Drools关注的是功能创新。对于用于开发、测试、技术预研的个人用户来说Drools是不错的选择。</li><li>Decision Manager 关注的是稳定性和可靠性，对于企业级用户来说Decision Manager是很好的选择，稳定、可靠、有保障、开箱即用。</li></ul>',30),t=[d];function c(h,u){return a(),i("div",null,t)}const b=e(n,[["render",c],["__file","drools01.html.vue"]]);export{b as default};
