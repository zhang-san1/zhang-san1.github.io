import{_ as i,W as e,X as a,Y as n}from"./framework-6447176f.js";const t="/assets/image-20220812094950452-57002b5c.png",d="/assets/image-20220812095036889-49d755d3.png",s="/assets/image-20220812095249528-772fe008.png",r="/assets/image-20220812090701239-3b442ccc.png",l="/assets/image-20220812090732663-db410759.png",c="/assets/image-20220812090801686-e35fe773.png",o="/assets/image-20220812095620392-f586e753.png",h="/assets/image-20220812101056065-cecd091d.png",p="/assets/image-20220812101432960-ca4aad79.png",g="/assets/image-20220812101550574-ebcc54d4.png",u="/assets/image-20220812104816824-d072252d.png",m="/assets/image-20220812104835141-fe614e87.png",b="/assets/5975b64b49e04180a01dd46f067c6c25-ed822bcb.png",v="/assets/4abdb0f7643c4893b2e29c3468611bb1-1fda25d3.png",_="/assets/a06659751d8b4c0ab800903cc5ba603d-52e30690.png",x="/assets/c17b574a4cbe48fe8667cd096dc44684-f2a86eb9.png",f="/assets/2ccaac0ecbf34f068a9d8409c7fbe8d7-a5c5fad1.png",G="/assets/ed4a0533c73e46d89ee3eaa730946e26-f7d21382.png",S="/assets/4b9d4ae9660c48258b4a00ae223e38ac-12e54af1.png",k="/assets/ce34386aa5f4466e9726ca64d0f33903-c3364fcc.png",y="/assets/baa3d27775cd4d108eb2edc952c66ad8-a7449d19.png",V={},q=n('<h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h1><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p><h2 id="_1-版本控制" tabindex="-1"><a class="header-anchor" href="#_1-版本控制" aria-hidden="true">#</a> 1 版本控制</h2><h3 id="_1-1-什么是版本控制" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是版本控制" aria-hidden="true">#</a> 1.1 什么是版本控制</h3><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li><li>简单说就是用于管理多人协同开发项目的技术。</li></ul><p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p><h3 id="_1-2-常见的版本控制工具" tabindex="-1"><a class="header-anchor" href="#_1-2-常见的版本控制工具" aria-hidden="true">#</a> 1.2 常见的版本控制工具</h3><p>主流的版本控制器有如下这些：</p><ul><li>Git</li><li>SVN（Subversion）</li><li>CVS（Concurrent Versions System）</li><li>VSS（Micorosoft Visual SourceSafe）</li><li>TFS（Team Foundation Server）</li><li>Visual Studio Online</li></ul><p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p><h3 id="_1-3-版本控制分类" tabindex="-1"><a class="header-anchor" href="#_1-3-版本控制分类" aria-hidden="true">#</a> 1.3 版本控制分类</h3><h4 id="_1-3-1-本地版本控制" tabindex="-1"><a class="header-anchor" href="#_1-3-1-本地版本控制" aria-hidden="true">#</a> 1.3.1 本地版本控制</h4><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><img src="'+t+'" alt="image-20220812094950452"></p><h4 id="_1-3-2-集中版本控制" tabindex="-1"><a class="header-anchor" href="#_1-3-2-集中版本控制" aria-hidden="true">#</a> 1.3.2 集中版本控制</h4><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。</p><p>代表产品：SVN、CVS、VSS</p><p><img src="'+d+'" alt="image-20220812095036889"></p><h4 id="_1-3-3-分布式版本控制" tabindex="-1"><a class="header-anchor" href="#_1-3-3-分布式版本控制" aria-hidden="true">#</a> 1.3.3 分布式版本控制</h4><p>每个人都拥有全部的代码，所以存在安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><p><img src="'+s+'" alt="image-20220812095249528"></p><h3 id="_1-4-git与svn的主要区别" tabindex="-1"><a class="header-anchor" href="#_1-4-git与svn的主要区别" aria-hidden="true">#</a> 1.4 Git与SVN的主要区别</h3><ul><li>SVN是<strong>集中式版本控制系统</strong>，版本库是集中<strong>放在中央服务器</strong>的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是<strong>必须联网才能工作，对网络带宽要求较高</strong>。</li><li>Git是<strong>分布式版本控制系统，没有中央服务器</strong>，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</li></ul><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><h2 id="_2-git的历史" tabindex="-1"><a class="header-anchor" href="#_2-git的历史" aria-hidden="true">#</a> 2 Git的历史</h2><p>Linux 内核开源项目有着为数众多的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p><p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p><h2 id="_3-git的安装和环境配置" tabindex="-1"><a class="header-anchor" href="#_3-git的安装和环境配置" aria-hidden="true">#</a> 3 Git的安装和环境配置</h2><h3 id="_3-1-git下载" tabindex="-1"><a class="header-anchor" href="#_3-1-git下载" aria-hidden="true">#</a> 3.1 Git下载</h3><blockquote><p>Git官网下载：https://git-scm.com/</p><p>淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows/</p></blockquote><p><strong>Git卸载</strong>：检查是否有Git相关的环境变量，如果有，删除；反安装即可卸载。</p><p><strong>Git Bash</strong>：Unix与Linux风格的命令行，使用最多，推荐最多</p><p><strong>Git CMD</strong>：Windows风格的命令行</p><p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p><h3 id="_3-2-git配置" tabindex="-1"><a class="header-anchor" href="#_3-2-git配置" aria-hidden="true">#</a> 3.2 Git配置</h3><p>使用<code>git config -l</code>命令查看Git配置</p><p><img src="'+r+'" alt="image-20220812090701239"></p><p>使用<code>git config --system --list</code>命令查看系统配置</p><p><img src="'+l+'" alt="image-20220812090732663"></p><p>使用<code>git config --global --list</code>命令查看当前用户（global）配置</p><p><img src="'+c+`" alt="image-20220812090801686"></p><p>所有的Git相关的配置文件，其实都保存在本地：</p><ul><li>Git\\etc\\gitconfig ：Git 安装目录下的 gitconfig <code>--system 系统级</code></li><li>C:\\Users\\Administrator\\ .gitconfig ：只适用于当前登录用户的配置 <code>--global 全局</code></li></ul><blockquote><p>注意：安装Git后首先要做的事情是设置用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git config --global user.name &quot;guoxin&quot;  #名称
git config --global user.email 1753510241@qq.com   #邮箱
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>只需要做一次这个设置，如果你传递了--global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。</p><p>如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项。</p><p>总之--global为全局配置，不加则为某个项目的特定配置。</p><h3 id="_3-3-基本的linux命令" tabindex="-1"><a class="header-anchor" href="#_3-3-基本的linux命令" aria-hidden="true">#</a> 3.3 基本的Linux命令</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cd        # 改变目
cd ..     # 回退到上一个目录，直接cd进入默认目录
pwd       # 显示当前所在的目录路径
ls(ll)    # 都是列出当前目录中的所有文件，只不过ll列出的内容更为详细
touch     # 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件
rm        # 删除一个文件, rm index.js 就会把index.js文件删除。
mkdir     # 新建一个目录,就是新建一个文件夹。
rm -r     # 删除一个文件夹, rm -r src 删除src目录
mv        # 移动文件
reset     # 重新初始化终端/清屏
clear     # 清屏
history   # 查看命令历史
help      # 帮助
exit      # 退出
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-git的基本理论" tabindex="-1"><a class="header-anchor" href="#_4-git的基本理论" aria-hidden="true">#</a> 4 Git的基本理论</h2><h3 id="_4-1-三个工作区域" tabindex="-1"><a class="header-anchor" href="#_4-1-三个工作区域" aria-hidden="true">#</a> 4.1 三个工作区域</h3><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。</p><p>如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。</p><p>文件在这四个区域之间的转换关系如下：</p><p><img src="`+o+'" alt="image-20220812095620392"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="'+h+'" alt="image-20220812101056065"></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><h3 id="_4-2-git的工作流程" tabindex="-1"><a class="header-anchor" href="#_4-2-git的工作流程" aria-hidden="true">#</a> 4.2 Git的工作流程</h3><p>１、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="'+p+'" alt="image-20220812101432960"></p><h2 id="_5-git项目搭建" tabindex="-1"><a class="header-anchor" href="#_5-git项目搭建" aria-hidden="true">#</a> 5 Git项目搭建</h2><h3 id="_5-1-创建工作目录与常用指令" tabindex="-1"><a class="header-anchor" href="#_5-1-创建工作目录与常用指令" aria-hidden="true">#</a> 5.1 创建工作目录与常用指令</h3><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p><img src="'+g+`" alt="image-20220812101550574"></p><h3 id="_5-2-本地仓库搭建" tabindex="-1"><a class="header-anchor" href="#_5-2-本地仓库搭建" aria-hidden="true">#</a> 5.2 本地仓库搭建</h3><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1、创建全新的仓库，需要用Git管理的项目的根目录执行：</p><div class="language-cmd line-numbers-mode" data-ext="cmd"><pre class="language-cmd"><code>git init # 在当前目录新建一个Git代码库
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><h3 id="_5-3-克隆远程仓库" tabindex="-1"><a class="header-anchor" href="#_5-3-克隆远程仓库" aria-hidden="true">#</a> 5.3 克隆远程仓库</h3><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><div class="language-cmd line-numbers-mode" data-ext="cmd"><pre class="language-cmd"><code>git clone [url] # 克隆一个项目和它的整个代码历史(版本信息)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、去 gitee 或者 github 上克隆一个测试！</p><h2 id="_6-git的文件操作命令" tabindex="-1"><a class="header-anchor" href="#_6-git的文件操作命令" aria-hidden="true">#</a> 6 Git的文件操作命令</h2><h3 id="_6-1-文件的四种状态" tabindex="-1"><a class="header-anchor" href="#_6-1-文件的四种状态" aria-hidden="true">#</a> 6.1 文件的四种状态</h3><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li><strong>Untracked</strong>： <ul><li>未跟踪，此文件在文件夹中，但并没有加入到git库，不参与版本控制</li><li>通过git add 状态变为Staged</li></ul></li><li><strong>Unmodify</strong>： <ul><li>文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致</li><li>这种类型的文件有两种去处： <ul><li>如果它被修改，而变为Modified</li><li>如果使用git rm移出版本库，则成为Untracked文件</li></ul></li></ul></li><li><strong>Modified</strong>： <ul><li>文件已修改，仅仅是修改，并没有进行其他的操作</li><li>这个文件也有两个去处： <ul><li>通过git add可进入暂存staged状态</li><li>使用git checkout 则丢弃修改过，返回到unmodify状态，这个git checkout即从库中取出文件，覆盖当前修改！</li></ul></li></ul></li><li><strong>Staged</strong>： <ul><li>暂存状态</li><li>执行git commit则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为Unmodify状态</li><li>执行git reset HEAD filename取消暂存，文件状态为Modified状态</li></ul></li></ul><h3 id="_6-2-查看文件状态" tabindex="-1"><a class="header-anchor" href="#_6-2-查看文件状态" aria-hidden="true">#</a> 6.2 查看文件状态</h3><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p><div class="language-cmd line-numbers-mode" data-ext="cmd"><pre class="language-cmd"><code>git status 					# 查看所有文件状态
git status [filename] 		#查看指定文件状态
git add .                  	# 添加所有文件到暂存区
git commit -m &quot;消息内容&quot;     # 提交暂存区中的内容到本地仓库 -m 提交信息
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-3-忽略文件" tabindex="-1"><a class="header-anchor" href="#_6-3-忽略文件" aria-hidden="true">#</a> 6.3 忽略文件</h3><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则：</p><ul><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,...}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ul><div class="language-cmd line-numbers-mode" data-ext="cmd"><pre class="language-cmd"><code>*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！
!lib.txt     #但lib.txt除外
/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp
build/       #忽略build/目录下的所有文件
doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-git的分支操作命令" tabindex="-1"><a class="header-anchor" href="#_7-git的分支操作命令" aria-hidden="true">#</a> 7 Git的分支操作命令</h2><blockquote><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。</p><p>不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p></blockquote><p><img src="`+u+'" alt="image-20220812104816824"></p><p><img src="'+m+`" alt="image-20220812104835141"></p><h3 id="_7-1-git分支中常用指令" tabindex="-1"><a class="header-anchor" href="#_7-1-git分支中常用指令" aria-hidden="true">#</a> 7.1 git分支中常用指令</h3><div class="language-cmd line-numbers-mode" data-ext="cmd"><pre class="language-cmd"><code># 列出所有本地分支
git branch

# 列出所有远程分支
git branch -r

# 新建一个分支，但依然停留在当前分支
git branch [branch-name]

# 新建一个分支，并切换到该分支
git checkout -b [branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]

# 本地分支关联远程分支
$ git branch --set-upstream-to=origin/tianshu(远程分支名) tianshu(本地分支名)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-idea-中解决git冲突" tabindex="-1"><a class="header-anchor" href="#_8-idea-中解决git冲突" aria-hidden="true">#</a> 8. Idea 中解决git冲突</h2><h3 id="_8-1-什么是冲突" tabindex="-1"><a class="header-anchor" href="#_8-1-什么是冲突" aria-hidden="true">#</a> 8.1 什么是冲突？</h3><p>冲突是指当你在提交或者更新代码时<strong>被合并的文件</strong>与<strong>当前文件不一致</strong></p><h3 id="_8-2-冲突的产生场景" tabindex="-1"><a class="header-anchor" href="#_8-2-冲突的产生场景" aria-hidden="true">#</a> 8.2 冲突的产生场景</h3><ul><li>两个分支之间进行push、pull操作 <ul><li>更新代码（一般是把远程的分支pull到本地）</li><li>提交代码（一般是把本地分支push到远程）</li></ul></li><li>两个分支之间进行merge操作 <ul><li>分支合并（一般是本地A分支merge到本地B分支，操作时首先切换到B分支，然后执行merge A）</li></ul></li></ul><p>总结：上面各种情况的<strong>本质都是当前文件与合并文件不一致</strong>，因此不论哪种情况其解决冲突的方法是一样的。</p><h3 id="_8-3-idea中解决冲突" tabindex="-1"><a class="header-anchor" href="#_8-3-idea中解决冲突" aria-hidden="true">#</a> 8.3 Idea中解决冲突</h3><h4 id="_8-3-1-模拟场景" tabindex="-1"><a class="header-anchor" href="#_8-3-1-模拟场景" aria-hidden="true">#</a> 8.3.1 模拟场景</h4><p>假设有两个程序员(张三、李四)同时开发一个项目，并且同时编写<strong>同一个文件的同一行</strong>。</p><h4 id="_8-3-2-程序员张三" tabindex="-1"><a class="header-anchor" href="#_8-3-2-程序员张三" aria-hidden="true">#</a> 8.3.2 程序员张三</h4><ul><li>张三新建了springconf.txt配置文件，往配置文件里写了点内容：</li></ul><p><img src="`+b+'" alt="在这里插入图片描述"></p><ul><li>上传到代码仓库：</li></ul><p><img src="'+v+'" alt="在这里插入图片描述"></p><h4 id="_8-4-3-程序员李四" tabindex="-1"><a class="header-anchor" href="#_8-4-3-程序员李四" aria-hidden="true">#</a> 8.4.3 程序员李四</h4><p>每次工作前先更新项目代码</p><ul><li>李四上班后，更新项目代码，修改springconf.txt 文件：</li></ul><p><img src="'+_+'" alt="在这里插入图片描述"></p><ul><li>然后提交到代码仓库： <img src="'+x+'" alt="在这里插入图片描述"></li></ul><h4 id="_8-4-4-张三又修改了springconf-txt文件" tabindex="-1"><a class="header-anchor" href="#_8-4-4-张三又修改了springconf-txt文件" aria-hidden="true">#</a> 8.4.4 张三又修改了springconf.txt文件</h4><ul><li>张三把代码写完后，准备提交代码了（<strong>这是时候提交到本地仓库了</strong>），在提交之前，先要拉取仓库的代码：</li></ul><p><img src="'+f+'" alt="在这里插入图片描述"></p><ul><li>出现冲突： <ul><li>程序员李四修改了springconf.txt文件，现在<strong>代码仓库的springconf.txt文件</strong>和<strong>张三本地的springconf.txt文件</strong>已经不一样了。</li></ul></li></ul><h3 id="_8-4-解决冲突" tabindex="-1"><a class="header-anchor" href="#_8-4-解决冲突" aria-hidden="true">#</a> 8.4 解决冲突</h3><ul><li>在拉取仓库代码时，出现冲突，此时会弹出一个会话框（两个单选框） <ul><li>选择 Merge 的话就是合并冲突</li><li>选择 Rebase 的话就是选择当前修改</li></ul></li></ul><p><img src="'+G+'" alt="在这里插入图片描述"></p><ul><li>选择 Merge...，此时会弹出一下会话框</li></ul><p><img src="'+S+'" alt="在这里插入图片描述"></p><ul><li>选择 Merge...，此时会弹出一下会话框</li></ul><p><img src="'+k+'" alt="在这里插入图片描述"></p><p>需要的内容点击：<code>&gt;&gt; </code> 既可合并内容到result中</p><p>不需要的内容点击 <code>X</code> 即可</p><p>合并完成后点击apply即可</p><p>需要注意的是，最将所有的 <code>X</code> <code>&gt;&gt;</code> 符号都要处理完！！！</p><p>手动合并后的文件内容如下：</p><p><img src="'+y+'" alt="在这里插入图片描述"></p><h4 id="张三解决冲突后-需要将项目推送到仓库中" tabindex="-1"><a class="header-anchor" href="#张三解决冲突后-需要将项目推送到仓库中" aria-hidden="true">#</a> 张三解决冲突后，需要将项目推送到仓库中</h4><h3 id="_8-5-总结" tabindex="-1"><a class="header-anchor" href="#_8-5-总结" aria-hidden="true">#</a> 8.5 总结</h3><ul><li>多人协作开发的时候，如果出现了你没有改过的文件跟你冲突了,一定要去找到当事者,说清楚是如何冲突的</li><li>然后协商解决，千万不要擅自拉别的分支去试图解决冲突，或找文件覆盖，更或者以自己的文件为准</li><li>同时记住，解决了之后，要add 和 commit 最后push</li><li>为保证万无一失，最后在冲突都解决之后，重启项目，保证至少不会有立即奔溃的现象发生，然后才去提交，push</li><li>提交的时候，一定要保持清醒，先搞清楚自己要提交的文件之间的关系，然后再提交，这样才不会有文件缺失的问题，造成奔溃</li></ul>',140),L=[q];function B(D,R){return e(),a("div",null,L)}const M=i(V,[["render",B],["__file","index.html.vue"]]);export{M as default};
